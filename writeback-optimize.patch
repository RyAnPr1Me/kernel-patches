From 6e7c8d4f9a5b3c2e7d1a9c4b6e8f3a5c7d9e1b4a Mon Sep 17 00:00:00 2001
From: Performance Patches <patches@kernel-perf.dev>
Date: Mon, 20 Jan 2025 15:20:00 +0000
Subject: [PATCH] mm: Optimize writeback for NVMe and fast storage

Adjust writeback parameters for modern NVMe SSDs with high IOPS:
- Higher dirty ratios to batch writes better
- Longer expire intervals for better coalescing  
- Zen 4-aware NUMA writeback

Zen 4 benefits:
- Better utilization of PCIe 5.0 bandwidth (up to 14GB/s per x16 slot)
- Reduced write amplification on NVMe SSDs
- Improved game loading and save times
- Better multi-threaded build performance

Signed-off-by: Performance Patches <patches@kernel-perf.dev>
---
 mm/page-writeback.c | 38 +++++++++++++++++++++++++++++++++-----
 1 file changed, 33 insertions(+), 5 deletions(-)

diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index f4e93d5c2562..d8e4c9f2a1b3 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -71,11 +71,14 @@ static long ratelimit_pages = 32;
  * Start background writeback (via writeback threads) at this percentage
  */
-static int dirty_background_ratio = 10;
+static int dirty_background_ratio = 20;
 
 /*
- * dirty_background_bytes starts at 0 (disabled) so that it is a function of
- * dirty_ratio * the amount of dirtyable memory
+ * Optimized for NVMe SSDs with high IOPS capability.
+ * Higher ratios allow better write coalescing and reduced
+ * write amplification on modern SSDs.
+ * 
+ * Zen 4 PCIe 5.0 can sustain 14GB/s - use it!
  */
 unsigned long dirty_background_bytes;
 
@@ -90,7 +93,7 @@ int vm_highmem_is_dirtyable;
 /*
  * The generator of dirty data starts writeback at this percentage
  */
-static int vm_dirty_ratio = 20;
+static int vm_dirty_ratio = 40;
 
 /*
  * vm_dirty_bytes starts at 0 (disabled) so that it is a function of
@@ -105,7 +108,7 @@ unsigned long vm_dirty_bytes;
  * Time the dirty data to disk before being written back
  * Increased for better batching on fast NVMe
  */
-unsigned int dirty_writeback_interval = 5 * 100; /* centiseconds */
+unsigned int dirty_writeback_interval = 15 * 100; /* centiseconds */
 
 EXPORT_SYMBOL_GPL(dirty_writeback_interval);
 
@@ -113,7 +116,10 @@ EXPORT_SYMBOL_GPL(dirty_writeback_interval);
  * Time after which dirty data is expired and will be written back
  * Longer interval for better write coalescing
  */
-unsigned int dirty_expire_interval = 30 * 100; /* centiseconds */
+unsigned int dirty_expire_interval = 60 * 100; /* centiseconds */
+
+/* Zen 4 NUMA-aware writeback threshold */
+static int zen4_numa_writeback __read_mostly = 1;
 
 /*
  * Flag that puts the machine in "laptop mode". Doubles as a timeout in jiffies:
@@ -1836,6 +1842,28 @@ static void balance_dirty_pages(struct bdi_writeback *wb,
 break;
 }
 
+/*
+ * Zen 4 NUMA optimization: On multi-CCD systems, try to keep
+ * dirty pages local to the node where they were allocated
+ * This reduces cross-CCX traffic and improves writeback performance
+ */
+if (zen4_numa_writeback && num_online_nodes() > 1) {
+int nid = page_to_nid(page);
+struct backing_dev_info *bdi = wb->bdi;
+
+/* Prefer local writeback on Zen 4 multi-CCD */
+if (nid == numa_node_id()) {
+/* Local page - can be more aggressive with caching */
+if (nr_reclaimable < background_thresh * 2)
+break;
+} else {
+/* Remote page - write back sooner to reduce cross-CCX traffic */
+if (nr_reclaimable > background_thresh / 2) {
+wb_start_background_writeback(wb);
+}
+}
+}
+
 if (unlikely(!writeback_in_progress(wb)))
 wb_start_background_writeback(wb);
 
-- 
2.43.0
