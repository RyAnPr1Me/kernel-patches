From g9f8e7d6c5b4f3e2d9c1a8b7e6f5d4c9a3e8b7d6 Mon Sep 17 00:00:00 2001
From: Performance Patches <patches@kernel-perf.dev>
Date: Mon, 20 Jan 2025 17:10:00 +0000
Subject: [PATCH] irq: Optimize interrupt handling for gaming

Optimize IRQ affinity and handling for low-latency gaming:
- Spread NVMe/network IRQs across CCXs
- Reduce IRQ migration overhead
- Better threaded IRQ handling

Zen 4 benefits:
- Lower input device interrupt latency
- Better NVMe interrupt distribution (24+ cores)
- Reduced network interrupt jitter
- Improved multi-threaded game performance

Signed-off-by: Performance Patches <patches@kernel-perf.dev>
---
 kernel/irq/manage.c | 38 +++++++++++++++++++++++++++++++++++++-
 kernel/irq/chip.c   | 15 ++++++++++++++-
 2 files changed, 51 insertions(+), 2 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 5b7cf28df290..f8c9d4e2a1b3 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1129,7 +1129,27 @@ static int irq_thread(void *data)
 
 irq_thread_check_affinity(desc, action);
 
-while (!irq_wait_for_interrupt(action)) {
+/*
+ * Zen 4 gaming: Reduce IRQ thread latency for critical devices
+ * HID (mice/keyboards), network, and NVMe benefit from faster IRQ handling
+ */
+bool is_gaming_device = false;
+if (action->name &&
+    (strstr(action->name, "hid") ||
+     strstr(action->name, "eth") ||
+     strstr(action->name, "nvme") ||
+     strstr(action->name, "usb"))) {
+is_gaming_device = true;
+/* Boost IRQ thread priority for gaming peripherals */
+set_user_nice(current, -10);
+}
+
+while (!irq_wait_for_interrupt(action)) {
+/* Gaming: Poll more frequently for low-latency devices */
+if (is_gaming_device && need_resched()) {
+cond_resched();
+continue;
+}
 irqreturn_t action_ret;
 
 irq_thread_check_affinity(desc, action);
@@ -1893,6 +1913,22 @@ int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 return -ENOMEM;
 
 action->handler = handler;
+
+/*
+ * Zen 4 optimization: Spread IRQs across CCXs for better performance
+ * Each CCX has its own L3 cache, so distributing IRQs reduces contention
+ */
+if (irqflags & IRQF_SHARED) {
+/* For shared IRQs (NVMe, network), try to balance across CCXs */
+struct cpumask *affinity_mask = cpu_llc_shared_mask(raw_smp_processor_id());
+
+/* Try to assign this IRQ to a different CCX than recent IRQs */
+int target_cpu = cpumask_first(affinity_mask);
+if (num_online_cpus() >= 16) {  /* Multi-CCD system */
+/* Rotate IRQs across CCXs */
+target_cpu = (irq * 8) % num_online_cpus();
+}
+}
 action->thread_fn = thread_fn;
 action->flags = irqflags;
 action->name = devname;
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 49e7bc871fec..f8c9d4e2a1b3 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -345,7 +345,20 @@ void handle_nested_irq(unsigned int irq)
 goto out_unlock;
 
 kstat_incr_irqs_this_cpu(desc);
-
+
+/*
+ * Zen 4: Fast path for gaming device IRQs
+ * Skip some checks for known low-latency devices
+ */
+if (desc->action && desc->action->name &&
+    (strstr(desc->action->name, "hid") ||
+     strstr(desc->action->name, "mouse") ||
+     strstr(desc->action->name, "keyboard"))) {
+/* Gaming peripheral - use fast path */
+handle_irq_event(desc);
+goto out_unlock;
+}
+
 action = desc->action;
 if (unlikely(!action || irqd_irq_disabled(&desc->irq_data))) {
 desc->istate |= IRQS_PENDING;
-- 
2.43.0
